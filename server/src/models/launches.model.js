const axios = require("axios");
const launchesDatabase = require("./launches.mongo");
const planets = require("./planets.mongo");

// const launches = new Map(); //Map, key value pair

const DEFAULT_FLIGHT_NUMBER = 100;

// let latestFlightNumber = 100;

// const launch = {
//   flightNumber: 100, //flight_number - in the SpaceX API
//   mission: "Kepler Exploration X", //name
//   rocket: "Explorer IS1",  //rocket.name
//   launchDate: new Date("December 27, 2030"), //date_local
//   target: "Kepler-442 b", //not applicable
//   customers: ["NASA", "Anson"], //payload.customers for each payload
//   upcoming: true, //upcoming
//   success: true, //success
// };

// saveLaunch(launch);
// launches.set(launch.flightNumber, launch); //key value pair, can be any value (including functions)

const SPACEX_API_URL = "https://api.spacexdata.com/v4/launches/query"

async function populateLaunches() {
  console.log('Downloading launch data...');
  const response = await axios.post(SPACEX_API_URL, {  //takes two arguments. First one is the URL, second is the data that we're passing in our POST request
    query: {},
    options: {
      pagination: false,
      populate: [
        {
          path: 'rocket',
          select: {
            name: 1 //1 means yes we want the data populated
          }
        },
        {
          path: 'payloads',
          select: {
            'customers': 1
          }
        }
      ]
    }
  });

  if (response.status !== 200) {
    console.log('Problem downloading launch data')
    throw new Error ('Launch data download failed') 
  } 

  const launchDocs = response.data.docs; //"data" is where axios puts the body of the response from the server. docs is the array that came back from postman
  for (const launchDoc of launchDocs) {

    const payloads = launchDoc['payloads']; //Mapping SpaceX Data to Our Database
    const customers = payloads.flatMap((payload) => { //flatmap takes an array of arrays and flattens it into one array: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap
      return payload['customers']
    })
    const launch = {
      flightNumber: launchDoc['flight_number'],
      mission: launchDoc['name'],
      rocket: launchDoc['rocket']['name'],
      launchDate: launchDoc['date_local'],
      upcoming: launchDoc['upcoming'],
      success: launchDoc['success'],
      customers: customers,
    };

    console.log(`${launch.flightNumber} ${launch.mission}`)
    await saveLaunch(launch)
  }
}


  async function loadLaunchData() {
    const firstLaunch = await findLaunch({ //before we load the SpaceX data we make sure it doesn't exist in our database yet
      flightNumber: 1,
      rocket: 'Falcon 1',
      mission: 'FalconSat',
    });
    if (firstLaunch) {
      console.log('Launch data already loaded!');
    } else {
      await populateLaunches();
    }
  }


async function findLaunch(filter) { //This function exists to find if the first spaceX launch has already been loaded into our database
  return await launchesDatabase.findOne(filter); //It ensures that we don't have to keep loading the data everytime as it is costly to load all of the launches
}

async function existsLaunchWithId(launchId) {
  //check if our launch has that ID
  return await findLaunch({
    flightNumber: launchId,
  });
}

async function getLatestFlightNumber() {
  //not necessary to export, we only use it in our launches model
  //getting the latest/highest flight number
  const latestLaunch = await launchesDatabase
    .findOne() //takes one aka the highest
    .sort("-flightNumber"); //sorts in descending order - highest to lowest

  if (!latestLaunch) {
    // if there are no flights we need to set a default flight number (100)
    return DEFAULT_FLIGHT_NUMBER;
  }

  return latestLaunch.flightNumber;
}

async function getAllLaunches(skip, limit) {
  // The array from method changes the iterables of launches.values into an array that contains those values. json() can only take js object or an array (which is also valid json)
  return await launchesDatabase
  .find({}, { _id: 0, __v: 0 }) //the second parameter excludes. So we are excluding the Object ID generated by mongo and the version key generated by mongoose
  .sort({ flightNumber: 1}) // -1 for descending order, 1 for ascending order. //this sorts our flights for pagination based on the flight number
  .skip(skip) //skips the first x documents 
  .limit(limit); //limit of launches shown per page
  // return Array.from(launches.values()); // Our launches is a map (key:value pair). We want the values.
} //for (const value of launches.values()){ ... }

async function saveLaunch(launch) {

  await launchesDatabase.findOneAndUpdate(
    {
      //Only returns the properties that we set in the update (aka launch) //only saves one launch at a time, therefore updateOne instead of updateMany
      flightNumber: launch.flightNumber, //if object with this flight number doesn't exist
    },
    launch, //if the object does exist, then update it with our launch object
    {
      upsert: true,
    }
  );
}

//Same as the function below but for our connected database
async function scheduleNewLaunch(launch) {
  const planet = await planets.findOne({
    //saves a launch assuming that all the properties of the launch are already set (particularly the flightnumber)
    kepler_name: launch.target, //mongoose operations are async. This functions saves our launches to MongoDB
  });

  if (!planet) {
    throw new Error("No matching planet was found"); //throwing error in a lower data access layer. It's thrown when we create a launch with a target planet that doesn't exist in our planets collection 
  }
  //increments flight number by 1, and assigns a few properties by default - properties that we don't need to send through our API
  const newFlightNumber = (await getLatestFlightNumber()) + 1; // because theyre not things the frontend is concerned with. We can calculate it in the backend (e.g., success: true)

  const newLaunch = Object.assign(launch, {
    success: true,
    upcoming: true,
    customers: ["Anson", "NASA"],
    flightNumber: newFlightNumber,
  });

  await saveLaunch(newLaunch);
}

// * When we stored the launches in memory:
// function addNewLaunch(launch) {
//     latestFlightNumber += 1; //setting the flight number on the server side, this makes it so that launch won't contain a flight number
//     launches.set( //Therefore we need to set the flight number on the launch object
//         latestFlightNumber, //key for our launch
//         Object.assign(launch, { //We still want to keep track of the flight number in our launch data so that it's returned from our api from getAllLaunches
//             success: true, //We need to add it to our launch object
//             upcoming: true, //The Object.assign takes the launch object and assigns some additional properties to it. If it already exists, it will overwrite it
//             customers: ['Anson, NASA'],
//             flightNumber: latestFlightNumber, //NOTE ** there are 8 values in the launch map, but we set 4 here to default values. This means the client needs to send us the other 4
//     })) //data that is determined on the server side
// }

async function abortLaunchById(launchId) {
  //abort launch
  const aborted = await launchesDatabase.updateOne(
    {
      flightNumber: launchId, //find
    },
    {
      upcoming: false, //update
      success: false,
    }
  ); //no upsert parameter because we don't want to insert a document into our launches collection if one doesn't exist

  return aborted.modifiedCount === 1; //ok and nModified is what returned in postman. when we just return await launches.Database.updateOne...
  // const aborted = launches.get(launchId);
  // aborted.upcoming = false;
  // aborted.success = false;
  // return aborted;
}

module.exports = {
  loadLaunchData,
  existsLaunchWithId,
  getAllLaunches,
  scheduleNewLaunch,
  abortLaunchById,
}
